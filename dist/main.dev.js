/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/modules/background.mjs":
/*!************************************!*\
  !*** ./src/modules/background.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setBackgroundOffset\": () => (/* binding */ setBackgroundOffset)\n/* harmony export */ });\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n/* harmony import */ var _motion_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./motion.mjs */ \"./src/modules/motion.mjs\");\n\r\n\r\n\r\nconst background = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\"#background-circles\");\r\n\r\nconst speed = 0.1;\r\nlet previousTime;\r\nlet position = {\r\n  x: 0,\r\n  y: 0,\r\n};\r\nlet backgroundOffset = 0;\r\n\r\nconst setBackgroundOffset = (offset) => (backgroundOffset = offset);\r\n\r\nconst animateBackground = (timestamp) => {\r\n  if (previousTime === undefined) {\r\n    previousTime = timestamp;\r\n    window.requestAnimationFrame(animateBackground);\r\n    return;\r\n  }\r\n  let delta = (timestamp - previousTime) / 60;\r\n  position.x +=\r\n    (-(_motion_mjs__WEBPACK_IMPORTED_MODULE_1__.motion.x + backgroundOffset * document.body.clientWidth) * speed -\r\n      position.x) *\r\n    delta *\r\n    speed;\r\n  position.y += (-_motion_mjs__WEBPACK_IMPORTED_MODULE_1__.motion.y * speed - position.y) * delta * speed;\r\n  background.setAttribute(\"x\", position.x);\r\n  background.setAttribute(\"y\", position.y);\r\n  previousTime = timestamp;\r\n  window.requestAnimationFrame(animateBackground);\r\n};\r\n\r\nwindow.requestAnimationFrame(animateBackground);\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.addVisibilitySubscriber)(() => (previousTime = undefined));\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/background.mjs?");

/***/ }),

/***/ "./src/modules/booklet.mjs":
/*!*********************************!*\
  !*** ./src/modules/booklet.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n/* harmony import */ var _hero_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hero.mjs */ \"./src/modules/hero.mjs\");\n\r\n\r\n\r\nconst booklet = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".booklet\");\r\nconst previous = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".print-previous>span\");\r\nconst next = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".print-next>span\");\r\nconst animations = [\r\n  \"Open1\",\r\n  \"Open2\",\r\n  \"Open3\",\r\n  \"Open4\",\r\n  \"Open5\",\r\n  \"Open6\",\r\n  \"Open7\",\r\n  \"Open8\",\r\n  \"Open9\",\r\n  \"Open10\",\r\n  \"Open11\",\r\n  \"Close\",\r\n  \"Flip\",\r\n];\r\nconst flipDuration = 1.25;\r\nconst fov = 95;\r\n\r\nlet index = animations.length - 1;\r\nlet pageIndex = 0;\r\nlet flipBackwards = false;\r\nlet offset = 0;\r\nlet canFlip = true;\r\n\r\nconst queueNextAnimation = () => {\r\n  let direction = flipBackwards ? -1 : 1;\r\n  index = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.mod)(index + direction + offset, animations.length);\r\n  pageIndex = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.mod)(pageIndex + direction, animations.length);\r\n  if (flipBackwards) {\r\n    booklet.animationName = animations[index] + \"R\";\r\n  } else {\r\n    booklet.animationName = animations[index];\r\n  }\r\n  booklet.currentTime = 0;\r\n};\r\n\r\nconst flip = (backwards = false) => {\r\n  if (!canFlip) return;\r\n  canFlip = false;\r\n  if (flipBackwards && !backwards) {\r\n    offset = -1;\r\n  } else if (!flipBackwards && backwards) {\r\n    offset = 1;\r\n  } else {\r\n    offset = 0;\r\n  }\r\n  flipBackwards = backwards;\r\n  queueNextAnimation();\r\n  if (pageIndex === 0) {\r\n    previous.innerHTML = \"Turn over\";\r\n    next.innerHTML = \"Open\";\r\n  } else if (pageIndex === 1) {\r\n    previous.innerHTML = \"Close\";\r\n    next.innerHTML = \"Next page\";\r\n  } else if (pageIndex < animations.length - 2) {\r\n    previous.innerHTML = \"Previous page\";\r\n    next.innerHTML = \"Next page\";\r\n  } else if (pageIndex === animations.length - 2) {\r\n    previous.innerHTML = \"Previous page\";\r\n    next.innerHTML = \"Close\";\r\n  } else if (pageIndex === animations.length - 1) {\r\n    previous.innerHTML = \"Open\";\r\n    next.innerHTML = \"Turn over\";\r\n  }\r\n  booklet.play();\r\n};\r\n\r\nconst updateFraming = () => {\r\n  booklet.updateFraming();\r\n  if (!canFlip) window.requestAnimationFrame(updateFraming);\r\n};\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(booklet, (e) => {\r\n  flip(e.clientX < booklet.clientWidth / 2);\r\n});\r\n\r\nbooklet.addEventListener(\"play\", (e) => {\r\n  window.requestAnimationFrame(updateFraming);\r\n  setTimeout(() => {\r\n    booklet.pause();\r\n    booklet.currentTime = flipDuration;\r\n    canFlip = true;\r\n  }, flipDuration * 1000);\r\n});\r\n\r\n(0,_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.orbitModel)(booklet, fov);\r\n\r\nif ((0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.hasTouch)()) {\r\n  previous.classList.add(\"touch\");\r\n  next.classList.add(\"touch\");\r\n}\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/booklet.mjs?");

/***/ }),

/***/ "./src/modules/content.mjs":
/*!*********************************!*\
  !*** ./src/modules/content.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"contentExpanded\": () => (/* binding */ contentExpanded),\n/* harmony export */   \"toggleExpandContent\": () => (/* binding */ toggleExpandContent),\n/* harmony export */   \"userContentExpanded\": () => (/* binding */ userContentExpanded)\n/* harmony export */ });\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n/* harmony import */ var _hero_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hero.mjs */ \"./src/modules/hero.mjs\");\n/* harmony import */ var _sections_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sections.mjs */ \"./src/modules/sections.mjs\");\n\r\n\r\n\r\n\r\nconst cooldown = 1000;\r\nconst expandContentButton = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".toggle-expand-content\");\r\n\r\nlet disableContentExpand = false;\r\n\r\nlet contentExpanded = false;\r\nlet userContentExpanded = false;\r\n\r\nconst toggleExpandContent = (user = false) => {\r\n  if (disableContentExpand) return;\r\n  disableContentExpand = true;\r\n  if (_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.expanded) (0,_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.toggleExpand)();\r\n  if (contentExpanded) {\r\n    _hero_mjs__WEBPACK_IMPORTED_MODULE_1__.expandButton.classList.remove(\"hidden\");\r\n    expandContentButton.classList.remove(\"expand\");\r\n    _hero_mjs__WEBPACK_IMPORTED_MODULE_1__.heroWindow.style.height = \"\";\r\n  } else {\r\n    _hero_mjs__WEBPACK_IMPORTED_MODULE_1__.expandButton.classList.add(\"hidden\");\r\n    expandContentButton.classList.add(\"expand\");\r\n    _hero_mjs__WEBPACK_IMPORTED_MODULE_1__.heroWindow.style.height = 0;\r\n  }\r\n  contentExpanded = !contentExpanded;\r\n  userContentExpanded = user && contentExpanded;\r\n  setTimeout(() => {\r\n    disableContentExpand = false;\r\n    if (!user) (0,_sections_mjs__WEBPACK_IMPORTED_MODULE_2__.syncScroll)();\r\n  }, cooldown);\r\n};\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(expandContentButton, () => {\r\n  toggleExpandContent(true);\r\n});\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/content.mjs?");

/***/ }),

/***/ "./src/modules/email.mjs":
/*!*******************************!*\
  !*** ./src/modules/email.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n\r\n\r\nconst emailLink = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".contact-email\");\r\nconst encryptedMail = \"7662756975726c727340656f6d2e2e6b77632e6f\";\r\nconst mailKey = \"msbehflqijgdakortncp\";\r\n\r\nlet decryptedMail = \"\";\r\n\r\nfor (const char of mailKey) {\r\n  let i = 2 * (char.charCodeAt(0) - 97);\r\n  decryptedMail += String.fromCharCode(\r\n    Number(\"0x\" + encryptedMail[i] + encryptedMail[i + 1])\r\n  );\r\n}\r\n\r\nemailLink.innerHTML = decryptedMail;\r\nemailLink.setAttribute(\"href\", \"mailto:\" + decryptedMail);\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/email.mjs?");

/***/ }),

/***/ "./src/modules/examples.mjs":
/*!**********************************!*\
  !*** ./src/modules/examples.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shrinkAll\": () => (/* binding */ shrinkAll)\n/* harmony export */ });\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n\r\n\r\nconst boxes = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".examples-container\");\r\n\r\nlet shrinkFunctions = [];\r\n\r\nfor (const box of boxes) {\r\n  const exampleCollection = {\r\n    currentIndex: 0,\r\n    slides: box.querySelectorAll(\".example-slider\"),\r\n    next: box.querySelector(\".examples-next\"),\r\n    previous: box.querySelector(\".examples-previous\"),\r\n    expand: box.querySelector(\".toggle-expand\"),\r\n    models: box.querySelectorAll(\"model-viewer\"),\r\n  };\r\n  const exampleCount = exampleCollection.slides.length;\r\n\r\n  let videos = [];\r\n  for (const slide of exampleCollection.slides) {\r\n    let htmlVideo = slide.querySelector(\"video\");\r\n    if (htmlVideo) {\r\n      videos.push({\r\n        play: () => {\r\n          htmlVideo.play();\r\n        },\r\n        pause: () => {\r\n          htmlVideo.pause();\r\n        },\r\n      });\r\n    } else {\r\n      videos.push({\r\n        play: () => {},\r\n        pause: () => {},\r\n      });\r\n    }\r\n  }\r\n\r\n  const chooseExample = () => {\r\n    exampleCollection.currentIndex = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.mod)(\r\n      exampleCollection.currentIndex,\r\n      exampleCount\r\n    );\r\n    videos[(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.mod)(exampleCollection.currentIndex - 1, exampleCount)].pause();\r\n    videos[exampleCollection.currentIndex].play();\r\n    for (let i = 0; i < exampleCount; i++) {\r\n      let offset = (exampleCollection.currentIndex * 100).toString() + \"%\";\r\n      exampleCollection.slides[i].style[\"margin-left\"] = \"-\" + offset;\r\n      exampleCollection.slides[i].style[\"margin-right\"] = offset;\r\n    }\r\n  };\r\n\r\n  const shrink = () => {\r\n    if (box.classList.contains(\"expand\")) {\r\n      console.log(\"Shrink?\");\r\n      box.classList.remove(\"expand\");\r\n      exampleCollection.expand.classList.remove(\"expand\");\r\n      for (const model of exampleCollection.models) {\r\n        model.setAttribute(\"disable-zoom\", \"\");\r\n        if ((0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.hasTouch)()) {\r\n          model.removeAttribute(\"camera-controls\");\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n  shrinkFunctions.push(shrink);\r\n\r\n  (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(exampleCollection.next, () => {\r\n    exampleCollection.currentIndex++;\r\n    chooseExample();\r\n  });\r\n\r\n  (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(exampleCollection.previous, () => {\r\n    exampleCollection.currentIndex--;\r\n    chooseExample();\r\n  });\r\n\r\n  (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(exampleCollection.expand, () => {\r\n    if (!shrink()) {\r\n      box.classList.add(\"expand\");\r\n      exampleCollection.expand.classList.add(\"expand\");\r\n      for (const model of exampleCollection.models) {\r\n        model.removeAttribute(\"disable-zoom\");\r\n        model.setAttribute(\"camera-controls\", \"\");\r\n      }\r\n    }\r\n  });\r\n\r\n  chooseExample();\r\n\r\n  if ((0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.hasTouch)()) {\r\n    for (const model of exampleCollection.models) {\r\n      model.removeAttribute(\"camera-controls\");\r\n    }\r\n  }\r\n}\r\n\r\nconst shrinkAll = () => {\r\n  for (const shrink of shrinkFunctions) shrink();\r\n};\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/examples.mjs?");

/***/ }),

/***/ "./src/modules/game.mjs":
/*!******************************!*\
  !*** ./src/modules/game.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pause\": () => (/* binding */ pause),\n/* harmony export */   \"reflow\": () => (/* binding */ reflow)\n/* harmony export */ });\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n\r\n\r\nconst gameWindow = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-container\");\r\nconst playButtons = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-play-button\");\r\nconst resumeButton = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-resume-button\");\r\nconst headerDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-header\");\r\nconst scoreDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-score-value\");\r\nconst healthDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-health-value\");\r\nconst overlayDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-overlay\");\r\nconst playDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-start\");\r\nconst gameoverDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-over\");\r\nconst highScoreDisplay = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".game-hi-score-value\");\r\nconst spritePath = \"img/hero/game/\";\r\nconst spritesheets = [\r\n  \"player\",\r\n  \"enemy\",\r\n  \"star\",\r\n  \"player_laser\",\r\n  \"enemy_orb\",\r\n  \"explosion\",\r\n  \"particle\",\r\n];\r\nconst staticSprites = [];\r\n\r\nconst playerSpawn = {\r\n  x: 0.5,\r\n  y: 0.95,\r\n};\r\nconst playerLaserOffset = {\r\n  x: 8,\r\n  y: 1,\r\n};\r\nconst enemyOrbOffset = {\r\n  x: 0,\r\n  y: 6,\r\n};\r\nconst playerLaserVelocity = -6;\r\nconst enemyOrbSpeed = 6;\r\nconst playerMaxVelocity = 10;\r\nconst playerAcceleration = 0.5;\r\nconst playerDecceleration = 0.8;\r\nconst arenaBounds = 8;\r\n\r\nconst enemyAdvanceSpeed = 3.5;\r\n\r\nconst virtualGameWidth = 192;\r\nconst minScale = 2;\r\nconst maxScale = 4;\r\n\r\nconst maxEnemies = 16;\r\nconst maxPlayerLasers = 32;\r\nconst maxEnemyOrbs = 128;\r\nconst maxHitParticles = 512;\r\n\r\nconst playerHealth = 100;\r\nconst enemyHealth = 20;\r\n\r\nconst playerLaserDamage = 10;\r\nconst enemyOrbDamage = 5;\r\n\r\nconst enemyFireRate = 1000; //Change to variable and decrease with difficulty later\r\nconst enemySpawnTick = 1200;\r\nconst enemySpawnBaseChance = 0.3;\r\nconst enemySpawnChanceIncrement = 0.1;\r\nconst enemyFireCutoff = 0.8;\r\n\r\nconst animationSpeed = 0.25;\r\nconst particleAnimationSpeed = 0.5;\r\n\r\nconst shootCooldown = 350;\r\n\r\nconst hitParticleAmount = 12;\r\nconst hitParticleSpeed = 2.5;\r\n\r\nconst frameTime = 1 / 60;\r\n\r\nconst shakeDuration = 1.0 / frameTime;\r\nconst shakeResolution = 28;\r\nconst shakeExponent = 2;\r\n\r\nconst playerDamageShake = 1.5;\r\nconst playerDeathShake = 3.0;\r\nconst killShake = 0.75;\r\n\r\nconst starData = {\r\n  S: {\r\n    amount: 100,\r\n    speed: 0.5,\r\n  },\r\n  M: {\r\n    amount: 20,\r\n    speed: 0.7,\r\n  },\r\n  L: {\r\n    amount: 10,\r\n    speed: 1.0,\r\n  },\r\n};\r\nconst starBounds = 7;\r\nconst starParallaxVariance = 0.3;\r\nconst starFieldSpeed = 0.5;\r\nconst starShakeParallax = 0.25;\r\n\r\nconst gameOverTimeout = 1000;\r\n\r\nlet game = new PIXI.Application({ resizeTo: gameWindow, backgroundAlpha: 0 });\r\nlet assets = {};\r\nlet entities = {\r\n  all: [],\r\n  player: null,\r\n  enemies: null,\r\n  playerLasers: null,\r\n  enemyOrbs: null,\r\n  explosions: null,\r\n  hitParticles: null,\r\n  stars: {\r\n    S: null,\r\n    M: null,\r\n    L: null,\r\n  },\r\n};\r\nlet gameReady = false;\r\nlet gameRunning = false;\r\nlet gamePaused = false;\r\nlet mouse = {\r\n  x: 0,\r\n  y: 0,\r\n};\r\nlet gameSize = {\r\n  w: gameWindow.clientWidth,\r\n  h: gameWindow.clientHeight,\r\n};\r\nlet shake = {\r\n  amount: 0,\r\n  magnitude: 0,\r\n  x: 0,\r\n  y: 0,\r\n  xPoints: [],\r\n  yPoints: [],\r\n};\r\nlet enemyDimensions;\r\nlet enemySpawnChance = 1.0;\r\nlet shooting = false;\r\nlet score = 0;\r\nlet highScore = 0;\r\ngameWindow.appendChild(game.view);\r\nPIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\r\nPIXI.settings.SORTABLE_CHILDREN = true;\r\n\r\nclass GameObject {\r\n  sprite;\r\n  active;\r\n  x;\r\n  y;\r\n  shakeParallax = 1.0;\r\n  canPause = true;\r\n  #velocity = new PIXI.Point(0, 0);\r\n  #normalizedPosition = new PIXI.Point(0, 0);\r\n\r\n  constructor(sprite, container = game.stage) {\r\n    this.sprite = sprite;\r\n    container.addChild(this.sprite);\r\n    this.active = false;\r\n    this.sprite.visible = false;\r\n    entities.all.push(this);\r\n  }\r\n\r\n  instance(x, y) {\r\n    if (this.sprite instanceof PIXI.AnimatedSprite) {\r\n      this.sprite.play();\r\n      this.sprite.animationSpeed = animationSpeed;\r\n    }\r\n    this.active = true;\r\n    this.sprite.visible = true;\r\n    this.sprite.anchor.set(0.5);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.updatePosition();\r\n    this.rescale();\r\n  }\r\n\r\n  kill() {\r\n    if (!this.active) return;\r\n    if (this.sprite instanceof PIXI.AnimatedSprite) {\r\n      this.sprite.stop();\r\n    }\r\n    this.active = false;\r\n    this.sprite.visible = false;\r\n  }\r\n\r\n  setVelocity(x, y) {\r\n    this.#velocity.x = x;\r\n    this.#velocity.y = y;\r\n  }\r\n\r\n  accelerate(x, y, max) {\r\n    this.#velocity.x += x;\r\n    this.#velocity.y += y;\r\n    if (Math.abs(this.#velocity.x) > max) {\r\n      this.#velocity.x = max * Math.sign(x);\r\n    }\r\n    if (Math.abs(this.#velocity.y) > max) {\r\n      this.#velocity.y = max * Math.sign(y);\r\n    }\r\n  }\r\n\r\n  decelerate(by) {\r\n    if (Math.abs(this.#velocity.x) < by) {\r\n      this.#velocity.x = 0;\r\n    } else {\r\n      this.#velocity.x -= by * Math.sign(this.#velocity.x);\r\n    }\r\n    if (Math.abs(this.#velocity.y) < by) {\r\n      this.#velocity.y = 0;\r\n    } else {\r\n      this.#velocity.y -= by * Math.sign(this.#velocity.y);\r\n    }\r\n  }\r\n\r\n  updatePosition() {\r\n    this.sprite.x = this.x + shake.x * this.shakeParallax;\r\n    this.sprite.y = this.y + shake.y * this.shakeParallax;\r\n  }\r\n\r\n  scale(x, y = null) {\r\n    if (y === null) y = x;\r\n    this.sprite.scale.x = x;\r\n    this.sprite.scale.y = y;\r\n  }\r\n\r\n  rescale() {\r\n    this.scale(globalScale());\r\n  }\r\n\r\n  savePosition() {\r\n    this.#normalizedPosition.x = this.x / gameSize.w;\r\n    this.#normalizedPosition.y = this.y / gameSize.h;\r\n  }\r\n\r\n  reflow() {\r\n    this.rescale();\r\n    this.x = this.#normalizedPosition.x * gameSize.w;\r\n    this.y = this.#normalizedPosition.y * gameSize.h;\r\n    this.updatePosition();\r\n  }\r\n\r\n  midLoop() {}\r\n\r\n  loop(delta) {\r\n    if (!this.active || (this.canPause && gamePaused)) return;\r\n    this.x += this.#velocity.x * delta;\r\n    this.y += this.#velocity.y * delta;\r\n    this.midLoop();\r\n    this.updatePosition();\r\n  }\r\n}\r\n\r\nclass Entity extends GameObject {\r\n  width;\r\n  height;\r\n  bounds;\r\n  collisionRadius;\r\n\r\n  constructor(sprite, collisionRadius = 1.0) {\r\n    super(sprite);\r\n    let spriteBounds = sprite.getLocalBounds();\r\n    this.width = spriteBounds.width;\r\n    this.height = spriteBounds.height;\r\n    this.collisionRadius = collisionRadius * this.width;\r\n  }\r\n\r\n  isCollidingWith(other) {\r\n    if (!this.active) return false;\r\n    let threshold = this.collisionRadius + other.collisionRadius;\r\n    threshold *= threshold;\r\n    threshold *= globalScale();\r\n    return vectorDistanceSquared(this, other) < threshold;\r\n  }\r\n\r\n  midLoop() {\r\n    if (this.bounds !== undefined) {\r\n      this.x = Math.max(\r\n        globalScale() * (this.bounds + this.width / 2.0),\r\n        Math.min(\r\n          this.x,\r\n          gameSize.w - globalScale() * (this.bounds + this.width / 2.0)\r\n        )\r\n      );\r\n      this.y = Math.max(\r\n        globalScale() * (this.bounds + this.height / 2.0),\r\n        Math.min(\r\n          this.y,\r\n          gameSize.h - globalScale() * (this.bounds + this.height / 2.0)\r\n        )\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nclass AnimatedParticle extends GameObject {\r\n  constructor(sprite) {\r\n    super(sprite);\r\n    sprite.onLoop = () => {\r\n      this.kill();\r\n    };\r\n    sprite.animationSpeed = particleAnimationSpeed;\r\n  }\r\n}\r\n\r\nclass Star extends GameObject {\r\n  #size;\r\n\r\n  constructor(sprite, size) {\r\n    super(sprite);\r\n    this.canPause = false;\r\n    this.#size = size;\r\n    this.shakeParallax = starShakeParallax;\r\n    switch (size) {\r\n      case \"L\":\r\n        this.sprite.zIndex = -11;\r\n        break;\r\n      case \"M\":\r\n        this.sprite.zIndex = -12;\r\n        break;\r\n      case \"S\":\r\n        this.sprite.zIndex = -13;\r\n        break;\r\n    }\r\n  }\r\n\r\n  instance(x, y) {\r\n    super.instance(x, y);\r\n    let speed = starData[this.#size].speed;\r\n    this.setVelocity(\r\n      0,\r\n      (speed +\r\n        (Math.random() * 2.0 - 1.0) * starParallaxVariance * (1.0 - speed)) *\r\n        starFieldSpeed *\r\n        globalScale()\r\n    );\r\n  }\r\n\r\n  kill() {\r\n    this.instance(\r\n      Math.floor(\r\n        Math.random() * (gameSize.w - starBounds * globalScale() * 2)\r\n      ) +\r\n        starBounds * globalScale(),\r\n      -starBounds\r\n    );\r\n  }\r\n\r\n  loop(delta) {\r\n    super.loop(delta);\r\n    if (this.y > gameSize.h + starBounds) {\r\n      this.kill();\r\n    }\r\n  }\r\n}\r\n\r\nclass Character extends Entity {\r\n  maxHealth;\r\n  health;\r\n  shakeMagnitude = killShake;\r\n\r\n  constructor(sprite, health) {\r\n    super(sprite);\r\n    this.maxHealth = health;\r\n    this.health = 0;\r\n  }\r\n\r\n  instance(x, y) {\r\n    super.instance(x, y);\r\n    this.health = this.maxHealth;\r\n  }\r\n\r\n  die() {\r\n    this.kill();\r\n    this.health = 0;\r\n  }\r\n\r\n  damage(amount) {\r\n    this.health -= amount;\r\n    if (this.health <= 0) {\r\n      entities.explosions.instanceNext(this.x, this.y);\r\n      shakeScreen(this.shakeMagnitude);\r\n      this.die();\r\n    }\r\n  }\r\n}\r\n\r\nclass Ordnance extends Entity {\r\n  armed;\r\n  #targets;\r\n  #damage;\r\n\r\n  constructor(sprite, targets, damage) {\r\n    super(sprite);\r\n    sprite.onLoop = () => {\r\n      this.kill();\r\n    };\r\n    this.sprite.animationSpeed = particleAnimationSpeed;\r\n    this.#targets = targets;\r\n    this.#damage = damage;\r\n    this.sprite.zIndex = -1;\r\n    game.stage.sortChildren();\r\n  }\r\n\r\n  instance(x, y) {\r\n    super.instance(x, y);\r\n    this.sprite.stop();\r\n    this.armed = true;\r\n  }\r\n\r\n  hit() {\r\n    this.armed = false;\r\n    this.setVelocity(0, 0);\r\n    this.sprite.play();\r\n    for (let i = 0; i < hitParticleAmount; i++) {\r\n      let particle = entities.hitParticles.instanceNext(this.x, this.y);\r\n      let angle = Math.random() * Math.PI * 2.0;\r\n      let speed =\r\n        hitParticleSpeed * globalScale() * (Math.random() * 0.5 + 0.5);\r\n      particle.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);\r\n    }\r\n  }\r\n\r\n  loop(delta) {\r\n    if (!this.active) return;\r\n    super.loop(delta);\r\n\r\n    if (\r\n      this.x < -this.width ||\r\n      this.x > gameSize.w + this.width ||\r\n      this.y < -this.height ||\r\n      this.y > gameSize.h + this.height\r\n    ) {\r\n      this.kill();\r\n      return;\r\n    }\r\n\r\n    if (!this.armed) return;\r\n\r\n    for (const target of this.#targets) {\r\n      if (!target.active) continue;\r\n      if (this.isCollidingWith(target)) {\r\n        target.damage(this.#damage);\r\n        this.hit();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Player extends Character {\r\n  #canShoot = true;\r\n  #alternate = false;\r\n\r\n  constructor(sprite, health) {\r\n    super(sprite, health);\r\n    this.bounds = arenaBounds;\r\n    this.shakeMagnitude = playerDeathShake;\r\n  }\r\n\r\n  die() {\r\n    super.die();\r\n    setTimeout(() => {\r\n      gameOver();\r\n    }, gameOverTimeout);\r\n  }\r\n\r\n  damage(amount) {\r\n    super.damage(amount);\r\n    updateHealth(this.health / this.maxHealth);\r\n    shakeScreen(playerDamageShake);\r\n  }\r\n\r\n  shoot() {\r\n    if (!gameRunning || !this.#canShoot) return;\r\n    let offsetX = playerLaserOffset.x + 0.5;\r\n    if (this.#alternate) {\r\n      offsetX = -playerLaserOffset.x - 0.5;\r\n    }\r\n    let laser = entities.playerLasers.instanceNext(\r\n      this.x + offsetX * globalScale(),\r\n      this.y + playerLaserOffset.y * globalScale()\r\n    );\r\n    laser.setVelocity(0, playerLaserVelocity * globalScale());\r\n    this.#alternate = !this.#alternate;\r\n    this.#canShoot = false;\r\n    setTimeout(() => {\r\n      this.#canShoot = true;\r\n    }, shootCooldown);\r\n  }\r\n\r\n  moveToMouse() {\r\n    if (!gameRunning) return;\r\n    let delta = mouse.x - this.x;\r\n    if (delta > playerMaxVelocity * globalScale()) {\r\n      this.accelerate(playerAcceleration, 0, playerMaxVelocity);\r\n    } else if (delta < -playerMaxVelocity * globalScale()) {\r\n      this.accelerate(-playerAcceleration, 0, playerMaxVelocity);\r\n    } else {\r\n      this.decelerate(playerDecceleration);\r\n    }\r\n  }\r\n\r\n  loop(delta) {\r\n    if (!this.active) return;\r\n    super.loop(delta);\r\n    if (shooting) this.shoot();\r\n    this.moveToMouse();\r\n  }\r\n}\r\n\r\nclass Enemy extends Character {\r\n  constructor(sprite, health) {\r\n    super(sprite, health);\r\n    if (enemyDimensions === undefined) {\r\n      enemyDimensions = {\r\n        w: this.width,\r\n        h: this.height,\r\n      };\r\n    }\r\n  }\r\n\r\n  instance(x, y) {\r\n    super.instance(x, y);\r\n    setTimeout(() => {\r\n      this.shoot();\r\n    }, enemyFireRate);\r\n  }\r\n\r\n  die() {\r\n    super.die();\r\n    updateScore(score + 1);\r\n  }\r\n\r\n  shoot() {\r\n    if (!this.active || !entities.player.active) return;\r\n    if (this.y > gameSize.h * enemyFireCutoff) return;\r\n    if (!gamePaused) {\r\n      let orb = entities.enemyOrbs.instanceNext(\r\n        this.x + enemyOrbOffset.x * globalScale(),\r\n        this.y + enemyOrbOffset.y * globalScale()\r\n      );\r\n      let direction = vectorDirection(this, entities.player);\r\n      orb.setVelocity(direction.x * enemyOrbSpeed, direction.y * enemyOrbSpeed);\r\n    }\r\n    setTimeout(() => {\r\n      this.shoot();\r\n    }, enemyFireRate);\r\n  }\r\n\r\n  loop(delta) {\r\n    if (!this.active) return;\r\n    super.loop(delta);\r\n    if (this.y > gameSize.h + this.height) {\r\n      this.kill();\r\n    }\r\n  }\r\n}\r\n\r\nclass EntityPool {\r\n  pool;\r\n  #amount;\r\n  #counter;\r\n\r\n  constructor(amount, entityCallback) {\r\n    this.#amount = amount;\r\n    this.#counter = 0;\r\n    this.pool = [];\r\n    for (let i = 0; i < amount; i++) {\r\n      this.pool.push(entityCallback());\r\n    }\r\n  }\r\n\r\n  instanceNext(x, y) {\r\n    if (gamePaused) return;\r\n    let instance = this.pool[this.#counter];\r\n    this.#counter = (this.#counter + 1) % this.#amount;\r\n    instance.instance(x, y);\r\n    return instance;\r\n  }\r\n\r\n  loop(delta) {\r\n    this.pool.forEach((entity) => {\r\n      entity.loop(delta);\r\n    });\r\n  }\r\n}\r\n\r\nconst globalScale = () => {\r\n  return Math.min(gameSize.w / virtualGameWidth, maxScale);\r\n};\r\n\r\nconst loadFromSpritesheet = (sheetName, resource) => {\r\n  return assets[sheetName][resource];\r\n};\r\n\r\nconst createAnimatedSprite = (sheetName, animation) => {\r\n  return new PIXI.AnimatedSprite(\r\n    loadFromSpritesheet(sheetName, \"animations\")[animation]\r\n  );\r\n};\r\n\r\nconst createStaticSpriteFromSheet = (sheetName, texture) => {\r\n  return new PIXI.Sprite(loadFromSpritesheet(sheetName, \"textures\")[texture]);\r\n};\r\n\r\nconst createStaticSprite = (name) => {\r\n  return new PIXI.Sprite(assets[name]);\r\n};\r\n\r\nconst vectorMagnitudeSquared = (vector) => {\r\n  return vector.x * vector.x + vector.y * vector.y;\r\n};\r\n\r\nconst vectorMagnitude = (vector) => {\r\n  return Math.sqrt(vectorMagnitudeSquared(vector));\r\n};\r\n\r\nconst vectorNormalized = (vector) => {\r\n  let magnitude = vectorMagnitude(vector);\r\n  return new PIXI.Point(vector.x / magnitude, vector.y / magnitude);\r\n};\r\n\r\nconst vectorDirection = (from, to) => {\r\n  return vectorNormalized(new PIXI.Point(to.x - from.x, to.y - from.y));\r\n};\r\n\r\nconst vectorDistanceSquared = (from, to) => {\r\n  return vectorMagnitudeSquared(new PIXI.Point(to.x - from.x, to.y - from.y));\r\n};\r\n\r\nconst vectorDistance = (from, to) => {\r\n  return Math.sqrt(vectorDistanceSquared(from, to));\r\n};\r\n\r\nconst applyShake = () => {\r\n  if (!shake.amount) return;\r\n  let samplePoint = shake.amount * (shakeResolution - 1);\r\n  let lerpAmount = samplePoint % 1;\r\n  let lerpFrom = Math.floor(samplePoint);\r\n  let lerpTo = Math.ceil(samplePoint);\r\n  let xAmount =\r\n    shake.xPoints[lerpFrom] * (1.0 - lerpAmount) +\r\n    shake.xPoints[lerpTo] * lerpAmount;\r\n  let yAmount =\r\n    shake.yPoints[lerpFrom] * (1.0 - lerpAmount) +\r\n    shake.yPoints[lerpTo] * lerpAmount;\r\n  let power = Math.pow(shake.amount, shakeExponent);\r\n  shake.x = shake.magnitude * power * xAmount * globalScale();\r\n  shake.y = shake.magnitude * power * yAmount * globalScale();\r\n  shake.amount -= 1.0 / shakeDuration;\r\n  if (shake.amount < 0) {\r\n    shake.x = 0;\r\n    shake.y = 0;\r\n    shake.amount = 0;\r\n  }\r\n};\r\n\r\nconst shakeScreen = (magnitude) => {\r\n  const scaledMagnitude = magnitude * globalScale();\r\n  if (shake.amount) {\r\n    shake.magnitude = shake.magnitude * shake.amount + scaledMagnitude;\r\n  } else {\r\n    shake.magnitude = scaledMagnitude;\r\n  }\r\n  shake.xPoints = [];\r\n  shake.yPoints = [];\r\n  for (let i = 0; i < shakeResolution; i++) {\r\n    shake.xPoints.push(Math.random() * 2.0 - 1.0);\r\n    shake.yPoints.push(Math.random() * 2.0 - 1.0);\r\n  }\r\n  shake.amount = 1.0;\r\n};\r\n\r\nconst reflow = () => {\r\n  if (!gameReady) return;\r\n  entities.all.forEach((entity) => {\r\n    entity.savePosition();\r\n  });\r\n  gameSize.w = gameWindow.clientWidth;\r\n  gameSize.h = gameWindow.clientHeight;\r\n  game.renderer.resize(gameSize.w, gameSize.h);\r\n  entities.all.forEach((entity) => {\r\n    entity.reflow();\r\n  });\r\n  entities.player.y = gameSize.h * playerSpawn.y;\r\n  entities.player.midLoop();\r\n  entities.player.updatePosition();\r\n};\r\n\r\nconst showHeader = () => {\r\n  headerDisplay.style.opacity = \"1\";\r\n};\r\n\r\nconst hideHeader = () => {\r\n  headerDisplay.style.opacity = \"0\";\r\n};\r\n\r\nconst showOverlay = () => {\r\n  overlayDisplay.style.opacity = \"1\";\r\n  overlayDisplay.style[\"pointer-events\"] = \"auto\";\r\n};\r\n\r\nconst hideOverlay = () => {\r\n  overlayDisplay.style.opacity = \"0\";\r\n  overlayDisplay.style[\"pointer-events\"] = \"none\";\r\n};\r\n\r\nconst updateScore = (newScore) => {\r\n  score = newScore;\r\n  if (score > highScore) {\r\n    highScore = score;\r\n    highScoreDisplay.innerHTML = highScore.toString();\r\n  }\r\n  scoreDisplay.forEach((scoreElement) => {\r\n    scoreElement.innerHTML = score.toString();\r\n  });\r\n};\r\n\r\nconst updateHealth = (health) => {\r\n  healthDisplay.style.width = (100 * health).toString() + \"%\";\r\n};\r\n\r\nconst spawnPlayer = () => {\r\n  if (!entities.player.active) {\r\n    entities.player.instance(\r\n      gameSize.w * playerSpawn.x,\r\n      gameSize.h * playerSpawn.y\r\n    );\r\n  }\r\n};\r\n\r\nconst spawnEnemy = () => {\r\n  if (gamePaused || !entities.player.active) return;\r\n  if (enemySpawnChance < 1.0 && Math.random() > enemySpawnChance) {\r\n    enemySpawnChance += enemySpawnChanceIncrement;\r\n    if (enemySpawnChance > 1.0) enemySpawnChance = 1.0;\r\n    setTimeout(() => {\r\n      spawnEnemy();\r\n    }, enemySpawnTick);\r\n    return;\r\n  }\r\n  let enemySpawnBounds =\r\n    (enemyDimensions.w / 2.0 + arenaBounds) * globalScale();\r\n  enemySpawnChance = enemySpawnBaseChance;\r\n  let enemy = entities.enemies.instanceNext(\r\n    Math.floor(Math.random() * (gameSize.w - enemySpawnBounds * 2)) +\r\n      enemySpawnBounds,\r\n    -enemyDimensions.h\r\n  );\r\n  enemy.setVelocity(0, enemyAdvanceSpeed);\r\n  setTimeout(() => {\r\n    spawnEnemy();\r\n  }, enemySpawnTick);\r\n};\r\n\r\nconst startGame = () => {\r\n  updateHealth(1.0);\r\n  updateScore(0);\r\n  hideOverlay();\r\n  showHeader();\r\n  spawnPlayer();\r\n  spawnEnemy();\r\n  reflow();\r\n  if (!gameoverDisplay.classList.contains(\"hidden\")) {\r\n    gameoverDisplay.classList.add(\"hidden\");\r\n  }\r\n  gameRunning = true;\r\n};\r\n\r\nconst gameOver = () => {\r\n  gameRunning = false;\r\n  if (!playDisplay.classList.contains(\"hidden\")) {\r\n    playDisplay.classList.add(\"hidden\");\r\n  }\r\n  if (gameoverDisplay.classList.contains(\"hidden\")) {\r\n    gameoverDisplay.classList.remove(\"hidden\");\r\n  }\r\n  if (!resumeButton.classList.contains(\"hidden\")) {\r\n    resumeButton.classList.add(\"hidden\");\r\n  }\r\n  showOverlay();\r\n  hideHeader();\r\n};\r\n\r\nconst pause = () => {\r\n  if (!gameRunning) return;\r\n  gamePaused = true;\r\n  if (!playDisplay.classList.contains(\"hidden\")) {\r\n    playDisplay.classList.add(\"hidden\");\r\n  }\r\n  if (resumeButton.classList.contains(\"hidden\")) {\r\n    resumeButton.classList.remove(\"hidden\");\r\n  }\r\n  showOverlay();\r\n  hideHeader();\r\n};\r\n\r\nconst resume = () => {\r\n  if (!gameRunning) return;\r\n  gamePaused = false;\r\n  if (!playDisplay.classList.contains(\"hidden\")) {\r\n    playDisplay.classList.add(\"hidden\");\r\n  }\r\n  hideOverlay();\r\n  showHeader();\r\n  setTimeout(() => {\r\n    spawnEnemy();\r\n  }, enemySpawnTick);\r\n};\r\n\r\nasync function loadAssets() {\r\n  for (const sheet of spritesheets) {\r\n    assets[sheet] = await PIXI.Assets.load(spritePath + sheet + \".json\");\r\n  }\r\n\r\n  for (const sprite of staticSprites) {\r\n    assets[sprite] = await PIXI.Assets.load(spritePath + sprite + \".json\");\r\n  }\r\n}\r\n\r\nconst loadGame = () => {\r\n  entities.player = new Player(\r\n    createAnimatedSprite(\"player\", \"fly\"),\r\n    playerHealth\r\n  );\r\n  entities.enemies = new EntityPool(maxEnemies, () => {\r\n    return new Enemy(createAnimatedSprite(\"enemy\", \"fly\"), enemyHealth);\r\n  });\r\n  entities.enemyOrbs = new EntityPool(maxEnemyOrbs, () => {\r\n    return new Ordnance(\r\n      createAnimatedSprite(\"enemy_orb\", \"hit\"),\r\n      [entities.player],\r\n      enemyOrbDamage\r\n    );\r\n  });\r\n  entities.playerLasers = new EntityPool(maxPlayerLasers, () => {\r\n    return new Ordnance(\r\n      createAnimatedSprite(\"player_laser\", \"hit\"),\r\n      entities.enemies.pool,\r\n      playerLaserDamage\r\n    );\r\n  });\r\n  entities.hitParticles = new EntityPool(maxHitParticles, () => {\r\n    return new AnimatedParticle(createAnimatedSprite(\"particle\", \"play\"));\r\n  });\r\n  entities.explosions = new EntityPool(maxEnemies, () => {\r\n    return new AnimatedParticle(createAnimatedSprite(\"explosion\", \"explode\"));\r\n  });\r\n  entities.stars.L = new EntityPool(starData.L.amount, () => {\r\n    return new Star(createStaticSpriteFromSheet(\"star\", \"starL\"), \"L\");\r\n  });\r\n  entities.stars.M = new EntityPool(starData.M.amount, () => {\r\n    return new Star(createStaticSpriteFromSheet(\"star\", \"starM\"), \"M\");\r\n  });\r\n  entities.stars.S = new EntityPool(starData.S.amount, () => {\r\n    return new Star(createStaticSpriteFromSheet(\"star\", \"starS\"), \"S\");\r\n  });\r\n  game.stage.sortChildren();\r\n\r\n  for (let i = 0; i < starData.L.amount; i++) {\r\n    entities.stars.L.instanceNext(\r\n      Math.floor(\r\n        Math.random() * (gameSize.w - starBounds * globalScale() * 2)\r\n      ) +\r\n        starBounds * globalScale(),\r\n      Math.random() * gameSize.h\r\n    );\r\n  }\r\n  for (let i = 0; i < starData.M.amount; i++) {\r\n    entities.stars.M.instanceNext(\r\n      Math.floor(\r\n        Math.random() * (gameSize.w - starBounds * globalScale() * 2)\r\n      ) +\r\n        starBounds * globalScale(),\r\n      Math.random() * gameSize.h\r\n    );\r\n  }\r\n  for (let i = 0; i < starData.S.amount; i++) {\r\n    entities.stars.S.instanceNext(\r\n      Math.floor(\r\n        Math.random() * (gameSize.w - starBounds * globalScale() * 2)\r\n      ) +\r\n        starBounds * globalScale(),\r\n      Math.random() * gameSize.h\r\n    );\r\n  }\r\n\r\n  mouse.x = gameSize.w / 2.0;\r\n  mouse.y = gameSize.h / 2.0;\r\n\r\n  game.ticker.add((delta) => {\r\n    entities.all.forEach((entity) => {\r\n      entity.loop(delta);\r\n    });\r\n\r\n    applyShake();\r\n  });\r\n\r\n  spawnPlayer();\r\n\r\n  setTimeout(() => {\r\n    reflow();\r\n  });\r\n  gameReady = true;\r\n};\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerInteraction)(game.view, \"pointerdown\", () => (shooting = true));\r\n\r\naddEventListener(\"pointerup\", () => (shooting = false));\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerInteraction)(game.view, \"pointermove\", (e) => {\r\n  mouse.x = e.x;\r\n  mouse.y = e.y;\r\n});\r\n\r\nplayButtons.forEach((button) => (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(button, () => startGame()));\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(resumeButton, () => resume());\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.addDeactivateSubscriber)(() => pause());\r\n\r\ndocument.body.addEventListener(\"click\", (e) => {\r\n  const bounds = gameWindow.getBoundingClientRect();\r\n  if (\r\n    e.pageX < bounds.left ||\r\n    e.pageX > bounds.right ||\r\n    e.pageY < bounds.top ||\r\n    e.pageY > bounds.bottom\r\n  ) {\r\n    pause();\r\n  }\r\n});\r\n\r\nnew ResizeObserver(reflow).observe(gameWindow);\r\n\r\nconst loader = loadAssets();\r\nloader.then(() => {\r\n  loadGame();\r\n});\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/game.mjs?");

/***/ }),

/***/ "./src/modules/global.mjs":
/*!********************************!*\
  !*** ./src/modules/global.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$\": () => (/* binding */ $),\n/* harmony export */   \"addActivateSubscriber\": () => (/* binding */ addActivateSubscriber),\n/* harmony export */   \"addDeactivateSubscriber\": () => (/* binding */ addDeactivateSubscriber),\n/* harmony export */   \"addVisibilitySubscriber\": () => (/* binding */ addVisibilitySubscriber),\n/* harmony export */   \"hasTouch\": () => (/* binding */ hasTouch),\n/* harmony export */   \"mod\": () => (/* binding */ mod),\n/* harmony export */   \"registerClick\": () => (/* binding */ registerClick),\n/* harmony export */   \"registerInteraction\": () => (/* binding */ registerInteraction),\n/* harmony export */   \"view\": () => (/* binding */ view)\n/* harmony export */ });\nconst mod = (n, m) => ((n % m) + m) % m;\r\n\r\nconst $ = (selector) => {\r\n  if (selector[0] === \"#\") return document.getElementById(selector.slice(1));\r\n  let all = document.querySelectorAll(selector);\r\n  if (!all) return null;\r\n  if (all.length === 1) return all[0];\r\n  return all;\r\n};\r\n\r\nconst registerInteraction = (element, listener, callback) => {\r\n  element.classList.add(\"interactable\");\r\n  element.addEventListener(listener, (event) => {\r\n    callback(event);\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n  });\r\n};\r\n\r\nconst registerClick = (element, callback) => {\r\n  registerInteraction(element, \"click\", callback);\r\n};\r\n\r\nconst view = () => {\r\n  return {\r\n    w: document.documentElement.clientWidth,\r\n    h: document.documentElement.clientHeight,\r\n  };\r\n};\r\n\r\nconst hasTouch = () => {\r\n  return (\r\n    \"ontouchstart\" in window ||\r\n    navigator.maxTouchPoints > 0 ||\r\n    navigator.msMaxTouchPoints > 0\r\n  );\r\n};\r\n\r\nlet activateSubscribers = [];\r\nlet deactivateSubscribers = [];\r\nlet visibilitySubscribers = [];\r\n\r\nconst addActivateSubscriber = (subscriber) =>\r\n  activateSubscribers.push(subscriber);\r\n\r\nconst addDeactivateSubscriber = (subscriber) =>\r\n  deactivateSubscribers.push(subscriber);\r\n\r\nconst addVisibilitySubscriber = (subscriber) =>\r\n  visibilitySubscribers.push(subscriber);\r\n\r\nconst updateVisibility = (active) => {\r\n  if (active) {\r\n    for (const subscriber of activateSubscribers) subscriber();\r\n    for (const subscriber of visibilitySubscribers) subscriber();\r\n  } else {\r\n    for (const subscriber of deactivateSubscribers) subscriber();\r\n    for (const subscriber of visibilitySubscribers) subscriber();\r\n  }\r\n};\r\n\r\naddEventListener(\"blur\", () => updateVisibility(false));\r\n\r\naddEventListener(\"focus\", () => updateVisibility(true));\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/global.mjs?");

/***/ }),

/***/ "./src/modules/hero.mjs":
/*!******************************!*\
  !*** ./src/modules/hero.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"expandButton\": () => (/* binding */ expandButton),\n/* harmony export */   \"expanded\": () => (/* binding */ expanded),\n/* harmony export */   \"heroWindow\": () => (/* binding */ heroWindow),\n/* harmony export */   \"orbitModel\": () => (/* binding */ orbitModel),\n/* harmony export */   \"toggleExpand\": () => (/* binding */ toggleExpand)\n/* harmony export */ });\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n/* harmony import */ var _motion_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./motion.mjs */ \"./src/modules/motion.mjs\");\n\r\n\r\n\r\nconst defaultYaw = 0;\r\nconst defaultPitch = 85.0;\r\nconst maxRot = 20.0;\r\nconst content = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".main\");\r\nconst footer = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\"footer\");\r\nconst sectionNav = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".section-nav\");\r\nconst shadows = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".shadow\");\r\n\r\nconst expandButton = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".window-overlay>.toggle-expand\");\r\nconst heroWindow = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".window\");\r\n\r\nconst orbitModel = (model, fov) => {\r\n  (0,_motion_mjs__WEBPACK_IMPORTED_MODULE_1__.addMotionSubscriber)(model, (x, y) => {\r\n    let centerX = heroWindow.clientWidth / 2;\r\n    let centerY = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.view)().h / 2;\r\n    let yaw = (-(x - centerX) / (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.view)().w) * maxRot + defaultYaw;\r\n    let pitch = (-(y - centerY) / (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.view)().h) * maxRot + defaultPitch;\r\n    model.cameraOrbit = `${yaw}deg ${pitch}deg ${fov}%`;\r\n  });\r\n};\r\n\r\nlet expanded = false;\r\n\r\nconst toggleExpand = () => {\r\n  if (expanded) {\r\n    document.body.classList.remove(\"expand\");\r\n    heroWindow.classList.remove(\"expand\");\r\n    content.classList.remove(\"shrink\");\r\n    expandButton.classList.remove(\"expand\");\r\n    footer.classList.remove(\"expand\");\r\n    sectionNav.classList.remove(\"expand\");\r\n    shadows.forEach((shadow) => {\r\n      shadow.classList.remove(\"shrink\");\r\n    });\r\n  } else {\r\n    document.body.classList.add(\"expand\");\r\n    heroWindow.classList.add(\"expand\");\r\n    content.classList.add(\"shrink\");\r\n    expandButton.classList.add(\"expand\");\r\n    footer.classList.add(\"expand\");\r\n    sectionNav.classList.add(\"expand\");\r\n    shadows.forEach((shadow) => {\r\n      shadow.classList.add(\"shrink\");\r\n    });\r\n  }\r\n  expanded = !expanded;\r\n};\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(expandButton, () => toggleExpand());\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/hero.mjs?");

/***/ }),

/***/ "./src/modules/motion.mjs":
/*!********************************!*\
  !*** ./src/modules/motion.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addMotionSubscriber\": () => (/* binding */ addMotionSubscriber),\n/* harmony export */   \"motion\": () => (/* binding */ motion)\n/* harmony export */ });\nclass Subscriber {\r\n  element;\r\n  callback;\r\n\r\n  constructor(element, callback) {\r\n    this.element = element;\r\n    this.callback = callback;\r\n  }\r\n\r\n  run(x, y) {\r\n    this.callback(x, y);\r\n  }\r\n}\r\n\r\nconst tiltStrength = 100;\r\n\r\nlet subscribers = [];\r\n\r\nlet motion = {\r\n  x: 0,\r\n  y: 0,\r\n};\r\n\r\nfunction updateSubscribers(x, y) {\r\n  motion.x = x;\r\n  motion.y = y;\r\n  subscribers.forEach((subscriber) => {\r\n    subscriber.run(x, y);\r\n  });\r\n}\r\n\r\nwindow.addEventListener(\"mousemove\", (e) => {\r\n  updateSubscribers(e.pageX, e.pageY);\r\n});\r\n\r\nwindow.addEventListener(\"devicemotion\", (e) => {\r\n  updateSubscribers(\r\n    e.accelerationIncludingGravity.x * tiltStrength,\r\n    e.accelerationIncludingGravity.y * tiltStrength\r\n  );\r\n});\r\n\r\nconst addMotionSubscriber = (element, callback) => {\r\n  subscribers.push(new Subscriber(element, callback));\r\n};\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/motion.mjs?");

/***/ }),

/***/ "./src/modules/music.mjs":
/*!*******************************!*\
  !*** ./src/modules/music.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n\r\n\r\nconst trackNames = [\"rendezvous\", \"behindthesun\", \"somarain\", \"behindglass\"];\r\nconst trackCount = trackNames.length;\r\nconst tick = 100;\r\nconst play = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-play-button\");\r\nconst previous = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-previous-button\");\r\nconst next = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-next-button\");\r\nconst seeker = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-seeker-bar\");\r\nconst progress = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-seeker-progress\");\r\nconst timestamp = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-seeker-timestamp\");\r\nconst duration = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-seeker-duration\");\r\nconst loading = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-loading\");\r\nconst times = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-seeker-times\");\r\nconst covers = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-album-art>div\");\r\nconst infoTrackNames = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-track-info>div\");\r\nconst playingIcon = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-play-button>.playing\");\r\nconst pausedIcon = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".music-play-button>.paused\");\r\n\r\nlet index = 0;\r\nlet loadedTracks = 0;\r\nlet seek = 0;\r\nlet allTracksLoaded = false;\r\nlet handleGrabbed = false;\r\nlet playing = false;\r\nlet ticker;\r\nlet tracks;\r\n\r\nconst secondsToMinutesString = (seconds) => {\r\n  let minutes = Math.floor(seconds / 60.0);\r\n  seconds = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.mod)(seconds, 60);\r\n  return (\r\n    minutes.toString() +\r\n    \":\" +\r\n    (new Array(3).join(\"0\") + Math.floor(seconds).toString()).slice(-2)\r\n  );\r\n};\r\n\r\nconst updateSeeker = () => {\r\n  if (!tracks[index].length) return;\r\n  progress.style.width = `${seek * 100}%`;\r\n  timestamp.innerHTML = secondsToMinutesString(tracks[index].length * seek);\r\n  duration.innerHTML = secondsToMinutesString(tracks[index].length);\r\n};\r\n\r\nconst updateTicker = () => {\r\n  if (playing) {\r\n    ticker = setInterval(() => {\r\n      if (!handleGrabbed) {\r\n        seek = tracks[index].audio.currentTime / tracks[index].length;\r\n        updateSeeker();\r\n      }\r\n    }, tick);\r\n  } else if (ticker !== undefined) {\r\n    clearInterval(ticker);\r\n  }\r\n};\r\n\r\nconst seekToX = (x) => {\r\n  seek = Math.max(0, Math.min(1, (x - seeker.offsetLeft) / seeker.clientWidth));\r\n  updateSeeker();\r\n  updateTicker();\r\n};\r\n\r\nconst chooseTrack = (trackOffset) => {\r\n  if (!allTracksLoaded) return;\r\n  if (playing) tracks[index].audio.pause();\r\n  index = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.mod)(index + trackOffset, trackCount);\r\n  seek = 0;\r\n  tracks[index].audio.currentTime = 0;\r\n  if (playing) tracks[index].audio.play();\r\n  updateSeeker();\r\n  updateTicker();\r\n  for (let i = 0; i < trackCount; i++) {\r\n    let offset = `${index * 100}%`;\r\n    covers[i].style[\"margin-left\"] = \"-\" + offset;\r\n    covers[i].style[\"margin-right\"] = offset;\r\n    infoTrackNames[i].style[\"margin-left\"] = \"-\" + offset;\r\n    infoTrackNames[i].style[\"margin-right\"] = offset;\r\n  }\r\n};\r\n\r\ntracks = trackNames.map((track) => {\r\n  return {\r\n    file: track,\r\n    audio: new Audio(`music/${track}.mp3`),\r\n    length: 0,\r\n  };\r\n});\r\n\r\ntracks.forEach((track) => {\r\n  track.audio.addEventListener(\"loadeddata\", () => {\r\n    track.length = track.audio.duration;\r\n    loadedTracks++;\r\n    if (loadedTracks === trackCount) {\r\n      allTracksLoaded = true;\r\n      loading.classList.add(\"hidden\");\r\n      seeker.classList.remove(\"hidden\");\r\n      times.classList.remove(\"hidden\");\r\n      updateSeeker();\r\n    }\r\n  });\r\n  track.audio.addEventListener(\"ended\", () => {\r\n    chooseTrack(1);\r\n  });\r\n});\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(next, () => {\r\n  chooseTrack(1);\r\n});\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(previous, () => {\r\n  chooseTrack(-1);\r\n});\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(play, () => {\r\n  if (!allTracksLoaded) return;\r\n  if (playing) {\r\n    tracks[index].audio.pause();\r\n    playingIcon.classList.add(\"hidden\");\r\n    pausedIcon.classList.remove(\"hidden\");\r\n  } else {\r\n    tracks[index].audio.play();\r\n    playingIcon.classList.remove(\"hidden\");\r\n    pausedIcon.classList.add(\"hidden\");\r\n  }\r\n  playing = !playing;\r\n  updateTicker();\r\n});\r\n\r\n(0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerInteraction)(seeker, \"pointerdown\", (e) => {\r\n  if (!allTracksLoaded) return;\r\n  handleGrabbed = true;\r\n  seekToX(e.x);\r\n});\r\n\r\naddEventListener(\"pointerup\", () => {\r\n  if (!handleGrabbed) return;\r\n  handleGrabbed = false;\r\n  tracks[index].audio.currentTime = tracks[index].length * seek;\r\n  updateTicker();\r\n});\r\n\r\naddEventListener(\"pointermove\", (e) => {\r\n  if (!handleGrabbed) return;\r\n  seekToX(e.x);\r\n});\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/music.mjs?");

/***/ }),

/***/ "./src/modules/portrait.mjs":
/*!**********************************!*\
  !*** ./src/modules/portrait.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n/* harmony import */ var _hero_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hero.mjs */ \"./src/modules/hero.mjs\");\n\r\n\r\n\r\nconst fov = 110;\r\n\r\n(0,_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.orbitModel)((0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".portrait\"), fov);\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/portrait.mjs?");

/***/ }),

/***/ "./src/modules/sections.mjs":
/*!**********************************!*\
  !*** ./src/modules/sections.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"syncScroll\": () => (/* binding */ syncScroll)\n/* harmony export */ });\n/* harmony import */ var _global_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.mjs */ \"./src/modules/global.mjs\");\n/* harmony import */ var _hero_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hero.mjs */ \"./src/modules/hero.mjs\");\n/* harmony import */ var _content_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./content.mjs */ \"./src/modules/content.mjs\");\n/* harmony import */ var _background_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./background.mjs */ \"./src/modules/background.mjs\");\n/* harmony import */ var _game_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./game.mjs */ \"./src/modules/game.mjs\");\n/* harmony import */ var _examples_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./examples.mjs */ \"./src/modules/examples.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst main = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\"main\");\r\nconst mainSections = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\"main>section\");\r\nconst windowSections = Array.from((0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".window>section\")).reverse();\r\nconst sectionAnchors = Array.from((0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".section-anchor\")).reverse();\r\nconst navButtons = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".section-nav>a\");\r\nconst bodyNavButtons = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\"main>section a:not(.contact-button)[href^='#']\");\r\nconst contactButtons = (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(\".contact-button\");\r\n\r\nlet sections = [];\r\nlet currentSection = sections[0];\r\nlet lastSection = sectionAnchors.length - 1;\r\n\r\nconst scrollToSection = (sectionIndex) => {\r\n  currentSection = sections[sectionIndex];\r\n  history.pushState(currentSection, \"\", currentSection);\r\n  for (const section of windowSections) {\r\n    let offset = (sectionIndex * 100).toString() + \"%\";\r\n    section.style[\"margin-left\"] = \"-\" + offset;\r\n    section.style[\"margin-right\"] = offset;\r\n    (0,_background_mjs__WEBPACK_IMPORTED_MODULE_3__.setBackgroundOffset)(sectionIndex);\r\n  }\r\n  if (currentSection === \"#game\") {\r\n    (0,_game_mjs__WEBPACK_IMPORTED_MODULE_4__.reflow)();\r\n  }\r\n  (0,_game_mjs__WEBPACK_IMPORTED_MODULE_4__.pause)();\r\n};\r\n\r\nconst anchorScrollToSection = (sectionIndex) => {\r\n  currentSection = sections[sectionIndex];\r\n  history.pushState(currentSection, \"\", currentSection);\r\n  if (_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.expanded) {\r\n    scrollToSection(sectionIndex);\r\n    return;\r\n  }\r\n  mainSections[sectionIndex].scrollIntoView({\r\n    behavior: \"smooth\",\r\n  });\r\n};\r\n\r\nconst registerScrollButton = (button, sectionIndex) => {\r\n  (0,_global_mjs__WEBPACK_IMPORTED_MODULE_0__.registerClick)(button, () => {\r\n    anchorScrollToSection(sectionIndex);\r\n    if (_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.expanded) location.hash = currentSection;\r\n    (0,_examples_mjs__WEBPACK_IMPORTED_MODULE_5__.shrinkAll)();\r\n  });\r\n};\r\n\r\nconst syncScroll = () => {\r\n  if (_hero_mjs__WEBPACK_IMPORTED_MODULE_1__.expanded) return;\r\n  let sectionIndex = lastSection;\r\n  for (const anchor of sectionAnchors) {\r\n    if (main.scrollTop + main.clientHeight > anchor.offsetTop) {\r\n      if (sectionIndex === lastSection) {\r\n        if (\r\n          !_content_mjs__WEBPACK_IMPORTED_MODULE_2__.userContentExpanded &&\r\n          !_content_mjs__WEBPACK_IMPORTED_MODULE_2__.contentExpanded &&\r\n          window.innerHeight >= window.innerWidth\r\n        ) {\r\n          (0,_content_mjs__WEBPACK_IMPORTED_MODULE_2__.toggleExpandContent)();\r\n        }\r\n        break;\r\n      } else if (\r\n        !_content_mjs__WEBPACK_IMPORTED_MODULE_2__.userContentExpanded &&\r\n        _content_mjs__WEBPACK_IMPORTED_MODULE_2__.contentExpanded &&\r\n        window.innerHeight >= window.innerWidth\r\n      ) {\r\n        (0,_content_mjs__WEBPACK_IMPORTED_MODULE_2__.toggleExpandContent)();\r\n      }\r\n      scrollToSection(sectionIndex);\r\n      break;\r\n    }\r\n    sectionIndex--;\r\n  }\r\n};\r\n\r\nmain.addEventListener(\"scroll\", () => syncScroll());\r\n\r\naddEventListener(\"resize\", () => {\r\n  if (_content_mjs__WEBPACK_IMPORTED_MODULE_2__.contentExpanded && window.innerHeight < window.innerWidth) {\r\n    (0,_content_mjs__WEBPACK_IMPORTED_MODULE_2__.toggleExpandContent)();\r\n  }\r\n  syncScroll();\r\n});\r\n\r\nlet sectionIndex = 0;\r\nfor (const button of navButtons) {\r\n  sections.push(button.getAttribute(\"href\"));\r\n  registerScrollButton(button, sectionIndex);\r\n  sectionIndex++;\r\n}\r\n\r\nfor (const button of contactButtons) {\r\n  registerScrollButton(button, sectionIndex);\r\n}\r\n\r\nfor (const button of bodyNavButtons) {\r\n  registerScrollButton(button, sections.indexOf(button.getAttribute(\"href\")));\r\n}\r\n\n\n//# sourceURL=webpack://portfolio/./src/modules/sections.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/modules/background.mjs");
/******/ 	__webpack_require__("./src/modules/booklet.mjs");
/******/ 	__webpack_require__("./src/modules/content.mjs");
/******/ 	__webpack_require__("./src/modules/email.mjs");
/******/ 	__webpack_require__("./src/modules/examples.mjs");
/******/ 	__webpack_require__("./src/modules/game.mjs");
/******/ 	__webpack_require__("./src/modules/global.mjs");
/******/ 	__webpack_require__("./src/modules/hero.mjs");
/******/ 	__webpack_require__("./src/modules/motion.mjs");
/******/ 	__webpack_require__("./src/modules/music.mjs");
/******/ 	__webpack_require__("./src/modules/portrait.mjs");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/modules/sections.mjs");
/******/ 	
/******/ })()
;